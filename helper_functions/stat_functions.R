library(data.table)
library(tidyverse)
library(GenomicRanges)
library(splitstackshape)
library(Publish) 

EMalgorithm <- function(T, N_1, N_2, N_3, eps){
  
  #object to store last generated matrix
  T_old <- matrix(c(0,0,0,0), ncol = 2, nrow = 2)
  
  while ( norm((T_old - T), type = "1")/4 > eps){
    
    #E-step
    #probabilities of all the possible paths with cycle lenght 2 and 3 
    p2_00 <- T[1,1]*T[1,1] + T[1,2]*T[2,1]
    p2_01 <- T[1,1]*T[1,2] + T[1,2]*T[2,2]
    p2_10 <- T[2,1]*T[1,1] + T[2,2]*T[2,1]
    p2_11 <- T[2,1]*T[1,2] + T[2,2]*T[2,2]
    p3_00 <- T[1,1]*T[1,1]*T[1,1] + T[1,1]*T[1,2]*T[2,1] + 
      T[1,2]*T[2,1]*T[1,1] + T[1,2]*T[2,2]*T[2,1]
    p3_01 <- T[1,1]*T[1,1]*T[1,2] + T[1,2]*T[2,1]*T[1,2] + 
      T[1,1]*T[1,2]*T[2,2] + T[1,2]*T[2,2]*T[2,2]
    p3_10 <- T[2,1]*T[1,1]*T[1,1] + T[2,2]*T[2,1]*T[1,1] + 
      T[2,1]*T[1,2]*T[2,1] + T[2,2]*T[2,2]*T[2,1]
    p3_11 <- T[2,1]*T[1,1]*T[1,2] + T[2,2]*T[2,1]*T[1,2] + 
      T[2,1]*T[1,2]*T[2,2] + T[2,2]*T[2,2]*T[2,2] 
    
    
    
    n00 <- N_1[1,1] + 2*N_2[1,1]*(T[1,1]*T[1,1]/p2_00) 
    + N_2[1,2]*(T[1,1]*T[1,2]/p2_01)
    + N_2[2,1]*(T[2,1]*T[1,1]/p2_10) 
    + N_3[1,1]*((T[1,2]*T[2,1]*T[1,1] + T[1,1]*T[1,2]*T[2,1] + 3*T[1,1]*T[1,1]*T[1,1])/p3_00)
    + N_3[1,2]*((T[1,1]*T[1,2]*T[2,2] + 2*T[1,1]*T[1,1]*T[1,2])/p3_01)
    + N_3[2,1]*((T[2,2]*T[2,1]*T[2,2] + 2*T[2,1]*T[1,1]*T[1,1])/p3_10)
    + N_2[2,2]*(T[2,1]*T[1,1]*T[1,2]/p3_11)
    
    n01 <- N_1[1,2] + N_2[1,1]*(T[1,2]*T[2,1]/p2_00) 
    + N_2[1,2]
    + N_2[2,2]*(T[2,1]*T[1,2]/p2_11)
    + N_3[1,1]*((T[1,2]*T[2,1]*T[1,1] + T[1,1]*T[1,2]*T[2,1] + T[1,2]*T[2,2]*T[2,1])/p3_00)
    + N_3[1,2] + N_3[1,2]*(T[1,2]*T[2,1]*T[1,2]/p3_01)
    + N_3[2,1]*(T[2,1]*T[1,2]*T[2,1]/p3_10)
    + N_2[2,2]*((T[2,1]*T[1,1]*T[1,2] + T[2,2]*T[2,1]*T[1,2] + T[2,1]*T[1,2]*T[2,2])/p3_11)
    
    n10 <- N_1[2,1] + N_2[1,1]*(T[1,2]*T[2,1]/p2_00) 
    + N_2[2,1]
    + N_2[2,2]*(T[2,1]*T[1,2]/p2_11)
    + N_3[1,1]*((T[1,2]*T[2,1]*T[1,1] + T[1,1]*T[1,2]*T[2,1] + T[1,2]*T[2,2]*T[2,1])/p3_00)
    + N_3[1,2]*(T[1,2]*T[2,1]*T[1,2]/p3_01)
    + N_3[2,1] + N_3[2,1]*(T[2,1]*T[1,2]*T[2,1]/p3_10)
    + N_2[2,2]*((T[2,1]*T[1,1]*T[1,2] + T[2,2]*T[2,1]*T[1,2] + T[2,1]*T[1,2]*T[2,2])/p3_11)
    
    n11 <- N_1[2,2] + N_2[1,2]*(T[1,2]*T[2,2]/p2_01) 
    + N_2[2,1]*(T[2,2]*T[2,1]/p2_10)
    + N_2[2,2]*(T[2,2]*T[2,2]/p2_11)*2
    + N_3[1,1]*(T[1,2]*T[2,2]*T[2,1]/p3_00)
    + N_3[1,2]*((T[1,1]*T[1,2]*T[2,2] + 2*T[1,2]*T[2,2]*T[2,2])/p3_01)
    + N_3[2,1]*((T[2,2]*T[2,1]*T[1,1]+ 2*T[2,2]*T[2,2]*T[2,1])/p3_10)
    + N_2[2,2]*((T[2,2]*T[2,1]*T[1,2] + T[2,1]*T[1,2]*T[2,2] + 3*T[2,2]*T[2,2]*T[2,2])/p3_11)
    
    #M-step
    T_old <- T
    T[1,1] <- n00/(n00+n01)
    T[1,2] <- n01/(n00+n01)
    T[2,1] <- n10/(n10+n11)
    T[2,2] <- n11/(n10+n11)
  }
  
  r_list <- list("Transition matrix" = T, "n00" = n00, "n01" = n01 , "n10" = n10, "n11" = n11)
  return(r_list)
  
}  
bootstrap <- function(em_list, N_1, N_2, N_3, b){ 
  '
  Input: list containing transition matrix and each 
  transition count generated by the EM-algorithm
  b: number of bootstrap samples
  Output: A list containing, bootstrap mean, bootstrap std for all transition 1-0, 0-1.
  Also, all the bootstrap estimates for the mentioned transitions for plotting.
  '
  #calculate bootstrap estimates
  perc <- 100
  boot_list <- list()
  b <- b
  for(i in 1:b){
    #n_star
    r_1_0 <- rmultinom(1, size = N_1[1,1]+N_1[1,2], prob = c(em_list[[1]][1,1],em_list[[1]][1,2]))
    r_1_1 <- rmultinom(1, size = N_1[2,1]+N_1[2,2], prob = c(em_list[[1]][2,1],em_list[[1]][2,2]))
    
    r_2_0 <- rmultinom(1, size = N_2[1,1]+N_2[1,2], prob = c(em_list[[1]][1,1],em_list[[1]][1,2]))
    r_2_1 <- rmultinom(1, size = N_2[2,1]+N_2[2,2], prob = c(em_list[[1]][2,1],em_list[[1]][2,2]))
    
    r_3_0 <- rmultinom(1, size = N_3[1,1]+N_3[1,2], prob = c(em_list[[1]][1,1],em_list[[1]][1,2]))
    r_3_1 <- rmultinom(1, size = N_3[2,1]+N_3[2,2], prob = c(em_list[[1]][2,1],em_list[[1]][2,2]))
    
    n_1_star <- rbind(matrix(r_1_0,1,2), matrix(r_1_1,1,2))
    n_2_star <- rbind(matrix(r_2_0,1,2), matrix(r_2_1,1,2))
    n_3_star <- rbind(matrix(r_3_0,1,2), matrix(r_3_1,1,2))
    
    T_start <- n_1_star / rowSums(n_1_star)
    
    eps <- 0.01
    
    boot_n <- EMalgorithm(T_start, n_1_star, n_2_star, n_3_star, eps)
    
    
    boot_list[i] <- list(boot_n[[1]]*perc) 
  }
  #assemble bootstrap estimates for unmethulated to methulated tranisiton probs
  boot_u_m <- vector()
  for(i in 1:b){
    boot_u_m[i] <- boot_list[[i]][1,2]
  }
  #assemble bootstrap estimates for methulated to unmethulated tranisiton probs
  boot_m_u <- vector()
  for(i in 1:b){
    boot_m_u[i] <- boot_list[[i]][2,1]
  }
  #derive mean and standard deviation of bootstrap estimates
  mean_u_m <- mean(boot_u_m)
  mean_m_u <- mean(boot_m_u)
  std_u_m <- sd(boot_u_m)
  std_m_u <- sd(boot_m_u)
  
  #derive normal 95% confidence intervals
  c_i_u_m <- ci.mean(boot_u_m)
  c_i_m_u <- ci.mean(boot_m_u)
  
  #create list of objects to return
  return_list <- list("mean_u_m" = mean_u_m, "mean_m_u" = mean_m_u, "std_u_m" = std_u_m, "std_m_u" = std_m_u, "c_i_u_m" = c_i_u_m,
                      "c_i_m_u" = c_i_m_u, "boot_est_u_m" = boot_u_m, "boot_est_m_u" = boot_m_u)
  return(return_list)
}
